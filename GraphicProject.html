<!DOCTYPE html>

<html>

  <head>
    <meta charset="UTF-8">
    <title>Tetris</title>

    <style type="text/css">

    </style>

  </head>

  <body>

    <canvas id="canvasOne" width="240" height="400"></canvas>

    <script type="text/javascript">
		//adapted from https://www.youtube.com/watch?v=H2aW5V46khA
		// Gets a handle to the element with id canvasOne.
		var canvas = document.getElementById("canvasOne");
		// Set the canvas up for drawing in 2D.
		var context = canvas.getContext("2d");
		
		//this makes everything inside the canvas bigger 20 times
		context.scale(20,20);
		
		//context.fillStyle = "rgb(255, 0, 0)";
		//context.fillRect(0,0,240,400);
		//context.fill();
		
		//these are the different shapes for the matrix
		function createPiece(type){
			if (type === 'I') {
				return [
					[0, 1, 0, 0],
					[0, 1, 0, 0],
					[0, 1, 0, 0],
					[0, 1, 0, 0],
				];
			} else if (type === 'L') {
				return [
					[0, 1, 0],
					[0, 1, 0],
					[0, 1, 1],
				];
			} else if (type === 'J') {
				return [
					[0, 1, 0],
					[0, 1, 0],
					[1, 1, 0],
				];
			} else if (type === 'O') {
				return [
					[1, 1],
					[1, 1],
				];
			} else if (type === 'Z') {
				return [
					[1, 1, 0],
					[0, 1, 1],
					[0, 0, 0],
				];
			} else if (type === 'S') {
				return [
					[0, 1, 1],
					[1, 1, 0],
					[0, 0, 0],
				];
			} else if (type === 'T') {
				return [
					[0, 1, 0],
					[1, 1, 1],
					[0, 0, 0],
				];
			}
		}
		//for collision detection		
		function collide(cm, player) {
			const m = player.matrix;
			const o = player.pos;
			for (let y = 0; y < m.length; ++y) {
				for (let x = 0; x < m[y].length; ++x) {
					if (m[y][x] !== 0 &&
					   (cm[y + o.y] &&
						cm[y + o.y][x + o.x]) !== 0) {
						return true;
					}
				}
			}
			return false;
		}

		
		//this make new matrixs 
		function createMatrix(width,height){
			
			const matrix = [];
			
			while(height--){
			
				matrix.push(new Array(width).fill(0));
			}
		
			return matrix;
		}
		
		//this makes the rectangle for the tetris
		//offset means the piece will be able to move 
		function drawMatrix(matrix, offset){
		
			matrix.forEach((row, y) => {
				row.forEach((value, x) => {
					if (value !== 0) {
						context.fillStyle = 'red';
						context.fillRect(x + offset.x, y + offset.y, 1, 1);
					}
				});
			});
		
		}
		
		//this saves the pieces in the arrays tables 
		function merge(cm,player){
			
			player.matrix.forEach((row, y) =>{
				
				row.forEach((value, x) =>{
					if (value !== 0) {
						cm[y + player.pos.y][x + player.pos.x] = value;
					}			
				});
			
			});	
		}
		
		//add a player structure 
		const player = {
			
			pos:{x:5,y:5},
			matrix: createPiece('T'),
		
		}
		
		//creates 20 arrays with 0s
		const cm = createMatrix(12,20);
		
		
		//this function calls the draw matrix function
		function draw(){
			//context.fillStyle = '#000';
			//context.clearRect(0, 0, canvas.width, canvas.height);
			context.fillStyle = '#000';
			context.fillRect(0,0,canvas.width,canvas.height);
			
			//this draws the pieces 
			drawMatrix(cm, {x: 0, y: 0});
			//call the function
			drawMatrix(player.matrix,player.pos);
		
		}
		
		//this rotates the pieces 
		function rotate(matrix, dir) {
			for (let y = 0; y < matrix.length; ++y) {
				//switch the matrix
				for (let x = 0; x < y; ++x) {
					[
						matrix[x][y],
						matrix[y][x],
					] = [
						matrix[y][x],
						matrix[x][y],
					];
				}
			}
			//check the direction
			if (dir > 0) {
				matrix.forEach(row => row.reverse());
			} else {
				matrix.reverse();
			}
		}
		
		//this function rotates the pieces and stops it from rotating it inside the wall
		function playerRotate(dir) {
			const pos = player.pos.x;
			let offset = 1;
			//call the function rotate
			rotate(player.matrix, dir);
			//this so it does not rotate inside the wall 
			while (collide(cm, player)) {
				player.pos.x += offset;
				offset = -(offset + (offset > 0 ? 1 : -1));
				if (offset > player.matrix[0].length) {
					rotate(player.matrix, -dir);
					player.pos.x = pos;
					return;
				}
			}
		}
		
		//resets player
		function playerReset() {
			const pieces = 'JLOTSZI';
			player.matrix = createPiece(pieces[pieces.length * Math.random() | 0]);
			player.pos.y = 0;
			//put the player in the middle
			player.pos.x = (cm[0].length / 2 | 0) -
						   (player.matrix[0].length / 2 | 0);
		}

		//this moves players left right
		function playerMove(offset) {
			
			 player.pos.x += offset;
			 if (collide(cm, player)) {
				 player.pos.x -= offset;
			 }
		}
		//variables that allow to move the piece 
		let dropCounter =0;
		let dropInterval =  1000;
		let lastTime = 0;
		
		//this function keeps the piece moving 
		function move(time= 0){
			//gets the difference
			const deltaTime = time - lastTime;
			lastTime = time;
			
			//this adds the difference 
			dropCounter += deltaTime;
			//if the difference adds up to 1000 or more it move the pos of the 
			//piece by 1
			if(dropCounter > dropInterval){
				playerDrop();
			}
			draw();
			requestAnimationFrame(move);
		}
		
		//this moves the piece by 1 downwards
		function playerDrop(){
			player.pos.y++;
			if(collide(cm, player)){
				player.pos.y--;
				merge(cm,player);
				playerReset();
			}
			dropCounter =0;
		}
		
		//this moves the pieces with keys 
		document.addEventListener('keydown', event => {
			if (event.keyCode === 37) {//left
				 playerMove(-1);
			}
			else if (event.keyCode === 39) {//right
				 playerMove(1);
			}
			else if (event.keyCode === 40) {//down
				playerDrop();
			}
			else if (event.keyCode === 81) {
				playerRotate(-1);
			} 
			else if (event.keyCode === 87) {
				playerRotate(1);
			}
		
		});
		//call the function
		move();
		

		
    </script>

  </body>

</html>